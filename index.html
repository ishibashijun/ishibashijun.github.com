---
layout: page
title: 
tagline:
---
{% include JB/setup %}
<!-- FOREGROUND -->
<style>
    body {
        overflow: hidden;
    }
    #fc-wrapper {
        position: relative;
        top: -60px;
        left: 0;
        z-index: 1;
        background-color: rgba(255, 255, 255, 0.4);
    }
</style>
<div id="fc-wrapper">
    <canvas id="fc"></canvas>
</div>
<script src="/assets/themes/custom/js/Box2dWeb-2.1.a.3.min.js"></script>
<script>
    var TWO_PI = 6.283185307179586;
    var width = $(window).width();
    var height = $(window).height();
    var centerX = width / 2;
    var centerY = height / 2;
    
    (function(global, undef) {
        "use strict";
        
        var canvas, ctx,
            w, h,
            halfW, halfH,
            mouse = {x: 0, y: 0},
            offset;
            
        /* Box2D includes */
        var b2Vec2          = Box2D.Common.Math.b2Vec2,
            b2BodyDef       = Box2D.Dynamics.b2BodyDef,
            b2Body          = Box2D.Dynamics.b2Body,
            b2FixtureDef    = Box2D.Dynamics.b2FixtureDef,
            b2Fixture       = Box2D.Dynamics.b2Fixture,
            b2World         = Box2D.Dynamics.b2World,
            b2DebugDraw     = Box2D.Dynamics.b2DebugDraw,
            b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
            b2AABB          = Box2D.Collision.b2AABB,
            b2MassData      = Box2D.Collision.Shapes.b2MassData,
            b2PolygonShape  = Box2D.Collision.Shapes.b2PolygonShape,
            b2CircleShape   = Box2D.Collision.Shapes.b2CircleShape;
        /* end Box2D includes */
            
        var cubes,
            mousePVec,
            isMouseDown,
            selectedBody,
            mouseJoint;
            
        var DEBUG = false,
            GRAVITY = 10,
            SLEEP = true,
            SCALE = 1 / 30,
            STEP = 1 / 24,
            VELOCITYITERATIONS = 10,
            POSITIONITERATIONS = 10,
            NUM = 6;
            
        var world,
            bodyDef = new b2BodyDef(),
            fixtureDef = new b2FixtureDef();
            
        var languages = {
            english: {lang: "Hello", width: 100, height: 40},
            japanese: {lang: "こんにちは", width: 140, height: 40},
            italian: {lang: "ciao", width: 80, height: 40},
            spanish: {lang: "hola", width: 80, height: 40},
            germany: {lang: "hallo", width: 100, height: 40},
            portuguese: {lang: "Ola", width: 70, height: 40}
        };

        function main() {
            initCanvas();
            createWorld();
            setFixtureDef(1.0, 0.5, 0.5);
            createWall();
            createCubes();
            
            if (DEBUG) {
                var debugDraw = new b2DebugDraw();
                
                debugDraw.SetSprite(ctx);
                debugDraw.SetDrawScale(30.0);
                debugDraw.SetFillAlpha(0.5);
                debugDraw.SetLineThickness(1.0);
                debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
                world.SetDebugDraw(debugDraw);
            }
            
            $(window).on("mousedown", onMouseDown);
            $(window).on("mouseup", onMouseUp);
            $(window).on("touchstart", onTouchStart);
            $(window).on("touchend", onTouchEnd);
        
            setInterval(render, 1000 / 30);
        }
        
        function render() {
            if(isMouseDown && !mouseJoint) {
                var body = getBodyAtMouse();
                
                if (body) {
                    var md = new b2MouseJointDef();
                    
                    md.bodyA = world.GetGroundBody();
                    md.bodyB = body;
                    md.target.Set(mouse.x, mouse.y);
                    md.collideConnected = true;
                    md.maxForce = 300.0 * body.GetMass();
                    mouseJoint = world.CreateJoint(md);
                    body.SetAwake(true);
                }
            }
        
            if (mouseJoint) {
                if (isMouseDown) {
                    mouseJoint.SetTarget(new b2Vec2(mouse.x, mouse.y));
                } else {
                    world.DestroyJoint(mouseJoint);
                    mouseJoint = null;
                }
            }
            
            world.Step(STEP, VELOCITYITERATIONS, POSITIONITERATIONS);
            
            if (DEBUG) world.DrawDebugData();
            
            world.ClearForces();
            
            if (!DEBUG) {
                ctx.clearRect(0, 0, w, h);
                
                drawCubes();
            }
        }
            
        function initCanvas() {
            w = width > 700 ? 700 : width;
            h = height - 20;
            halfW = w / 2;
            halfH = h / 2;
            canvas = $("#fc");
            canvas.attr("width", w);
            canvas.attr("height", h);
            canvas.css({
                zIndex: "2",
                width: w + "px",
                height: h + "px"
            });
            ctx = canvas.get(0).getContext("2d");
            offset = canvas.offset();
            
            var wrapper = $("#fc-wrapper").css({
                width: w + "px",
                height: h + "px"
            });
        }
        
        function createWorld() {
            world = new b2World(new b2Vec2(0, GRAVITY), SLEEP);
        }
        
        function setFixtureDef(density, restitution, friction) {
            fixtureDef.density = density;
            fixtureDef.restitution = restitution;
            fixtureDef.friction = friction;
        }
    
        function createWall() {
            var shape = new b2PolygonShape(),
                thickness = 5;
            
            fixtureDef.shape = shape;
            bodyDef.type = b2Body.b2_staticBody;
            
            shape.SetAsBox(w * SCALE, thickness * SCALE);
            bodyDef.position.Set(halfW * SCALE, -h * SCALE);
            world.CreateBody(bodyDef).CreateFixture(fixtureDef);
            bodyDef.position.Set(halfW * SCALE, (h + thickness) * SCALE);
            world.CreateBody(bodyDef).CreateFixture(fixtureDef);
        
            shape.SetAsBox(thickness * SCALE, 2 * h * SCALE);
            bodyDef.position.Set(-thickness * SCALE, 0);
            world.CreateBody(bodyDef).CreateFixture(fixtureDef);
            bodyDef.position.Set((w + thickness) * SCALE, 0);
            world.CreateBody(bodyDef).CreateFixture(fixtureDef);
        }
        
        function createCubes() {
            var i = 0,
                x, y;
                
            var shape = new b2PolygonShape();
            
            bodyDef.type = b2Body.b2_dynamicBody;
            fixtureDef.shape = shape;
            cubes = [];
            
            for (var key in languages) {
                shape.SetAsBox(languages[key].width * SCALE, languages[key].height * SCALE);
                bodyDef.position.x = Math.random() * w * SCALE;
                bodyDef.position.y = Math.random() * 0.2 * SCALE;
                
                cubes.push(
                    {
                        "lang": languages[key].lang,
                        "body": world.CreateBody(bodyDef),
                        "size": {width: languages[key].width, height: languages[key].height},
                        "color": "#" + ((Math.random() * 0x1000000) >> 0).toString(16)
                    }
                );
                
                cubes[i++].body.CreateFixture(fixtureDef);
            }
        }
        
        function drawCubes() {
            var pos,
                size;
            
            cubes.forEach(function(element, index, array) {
                pos = element.body.GetPosition();
                size = element.size;
                
                ctx.save();
                ctx.fillStyle = element.color;
                ctx.translate(pos.x / SCALE, pos.y / SCALE);
                ctx.rotate(element.body.GetAngle());
                ctx.fillRect(-size.width, -size.height, size.width * 2, size.height * 2);
                ctx.font = "50px Georgia";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "black";
                ctx.fillText(element.lang, 0, 0);
                ctx.restore();
            });
        }
        
        function getBodyAtMouse() {
            mousePVec = new b2Vec2(mouse.x, mouse.y);
            
            var aabb = new b2AABB();
            
            aabb.lowerBound.Set(mouse.x - 0.001, mouse.y - 0.001);
            aabb.upperBound.Set(mouse.x + 0.001, mouse.y + 0.001);
        
            selectedBody = null;
            world.QueryAABB(getBodyCB, aabb);
            
            return selectedBody;
        }
        
        function getBodyCB(fixture) {
            if (fixture.GetBody().GetType() !== b2Body.b2_staticBody) {
                if (fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    selectedBody = fixture.GetBody();
                    
                    return false;
                }
            }
            return true;
        }
        
        function onMouseDown(e) {
            isMouseDown = true;
            mouse.x = (e.clientX - offset.left) * SCALE;
            mouse.y = (e.clientY - offset.top) * SCALE;
            
            canvas.on("mousemove", onMouseMove);
        }
        
        function onMouseUp(e) {
            isMouseDown = false;
            
            canvas.off("mousemove");
        }
        
        function onMouseMove(e) {
            mouse.x = (e.clientX - offset.left) * SCALE;
            mouse.y = (e.clientY - offset.top) * SCALE;
        }
        
        function onTouchStart(e) {
            isMouseDown = true;
            mouse.x = (e.clientX - offset.left) * SCALE;
            mouse.y = (e.clientY - offset.top) * SCALE;
            
            canvas.on("touchmove", onTouchMove);
        }
        
        function onTouchEnd(e) {
            isMouseDown = false;
            
            canvas.off("touchmove");
        }
        
        function onTouchMove(e) {
            mouse.x = (e.clientX - offset.left) * SCALE;
            mouse.y = (e.clientY - offset.top) * SCALE;
        }
            
        main();
    })(window);
</script>
<!-- END FOREGROUND -->

<!-- BACKGROUND -->
<style>
    #bc {
        background-color: rgba(30, 30, 30, 0.1);
    }
</style>
<canvas id="bc"></canvas>
<script>
    (function(global, undef) {
        "use strict";
        
        var canvas, ctx,
            offset,
            num = Random(25, 40, false),
            cubes = [],
            balls = [],
            mouse = {x: 0, y: 0},
            fl = 250;
            
        function main() {
            init();
            
            setInterval(render, 1000 / 30);
        }
        
        function render() {
            ctx.clearRect(0, 0, width, height);
            
            cubes.forEach(function(element, index, array) {
               element.draw(balls[index]); 
            });
            
            var distX = mouse.x - centerX,
                distY = mouse.y - centerY,
                ratio;
            
            cubes.forEach(function(element, index, array) {
               if (element.width > 30) ratio = 0.3;
               else if (element.width > 20) ratio = 0.09;
               else ratio = 0.05;
               
               array[index].x = element.vx + distX * ratio;
               array[index].y = element.vy + distY * ratio;
            });
        }
        
        function init() {
            canvas = $("#bc");
            canvas.attr("width", width);
            canvas.attr("height", height);
            canvas.css({
                position: "fixed",
                top: "0px",
                left: "0px",
                zIndex: "0",
                width: width + "px",
                height: height + "px"
            });
            ctx = canvas.get(0).getContext("2d");
            offset = canvas.offset();
            
            $(window).mousemove(function(e) {
                mouse.x = e.pageX - offset.left;
                mouse.y = e.pageY - offset.top;
            });
            
            var i = num;
            
            for (; i--;) {
                cubes.push(new Cube(Random(30, 80, true), Random(width), Random(height), RGB(Hex2color(Random(16777215)))));
                balls.push(new Array(8));
            }
            
            cubes.forEach(function(element, index, array) {
                balls[index][0] = new Ball( element.width,  element.width,  element.width, element.color);
                balls[index][1] = new Ball( element.width,  element.width, -element.width, element.color);
                balls[index][2] = new Ball(-element.width,  element.width, -element.width, element.color);
                balls[index][3] = new Ball(-element.width,  element.width,  element.width, element.color);
                balls[index][4] = new Ball( element.width, -element.width,  element.width, element.color);
                balls[index][5] = new Ball( element.width, -element.width, -element.width, element.color);
                balls[index][6] = new Ball(-element.width, -element.width, -element.width, element.color);
                balls[index][7] = new Ball(-element.width, -element.width,  element.width, element.color);
            })
        }
        
        function Cube(width, x, y, color){
            this.width = width / 2;
            this.x = x;
            this.y = y;
            this.vx = x;
            this.vy = y;
            this.color = color;
            this.num = 8;
        }
        
        function Ball(posX, posY, posZ, color) {
            this.x = 0;
            this.y = 0;
            this.r = 2;
            this.color = color;
            this.posX = posX;
            this.posY = posY;
            this.posZ = posZ;
            this.scaleX = 1;
            this.scaleY = 1;
            this.rotation = 0;
        }
        
        Cube.prototype.drawBall = function(b){
            ctx.save();
            ctx.beginPath();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.rotation);
            ctx.scale(b.scaleX, b.scaleY);
            ctx.fillStyle = b.color;
            ctx.arc(0, 0, b.r, 0, TWO_PI);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 0.5;
            ctx.arc(0, 0, b.r * 2, 0, TWO_PI);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        };
        
        Cube.prototype.rotateX = function(b, angle){
            var cos = Math.cos(angle),
                sin = Math.sin(angle),
                y1 = b.posY * cos - b.posZ * sin,
                z1 = b.posZ * cos + b.posY * sin;
                
            b.posY = y1;
            b.posZ = z1;
        };
        
        Cube.prototype.rotateY = function(b, angle){
            var cos = Math.cos(angle),
                sin = Math.sin(angle),
                x1 = b.posX * cos - b.posZ * sin,
                z1 = b.posZ * cos + b.posX * sin;
                
            b.posX = x1;
            b.posZ = z1;
        };
        
        Cube.prototype.setPerspective = function(b){
            if(b.posZ > -fl){
                var scale = fl / (fl + b.posZ);
                
                b.scaleX = b.scaleY = scale;
                b.x = this.x + b.posX * scale;
                b.y = this.y + b.posY * scale;
            }
        };
        
        Cube.prototype.move = function(b, ax, ay){
            this.rotateX(b, ax);
            this.rotateY(b, ay);
            this.setPerspective(b);
        };
        
        Cube.prototype.draw = function(b){
            var	angleX = (mouse.y - this.y) * 0.0001,
                angleY = (mouse.x - this.x) * 0.0001,
                i, len = this.num;
                
            for (i = 0; i < len; i++) {
                this.move(b[i], angleX, angleY);
                this.drawBall(b[i]);
            }
            
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = this.color;
            ctx.moveTo(b[0].x, b[0].y);
            ctx.lineTo(b[1].x, b[1].y);
            ctx.lineTo(b[2].x, b[2].y);
            ctx.lineTo(b[3].x, b[3].y);
            ctx.lineTo(b[0].x, b[0].y);
            ctx.lineTo(b[4].x, b[4].y);
            ctx.lineTo(b[5].x, b[5].y);
            ctx.lineTo(b[6].x, b[6].y);
            ctx.lineTo(b[7].x, b[7].y);
            ctx.lineTo(b[4].x, b[4].y);
            ctx.moveTo(b[1].x, b[1].y);
            ctx.lineTo(b[5].x, b[5].y);
            ctx.moveTo(b[2].x, b[2].y);
            ctx.lineTo(b[6].x, b[6].y);
            ctx.moveTo(b[3].x, b[3].y);
            ctx.lineTo(b[7].x, b[7].y);
            ctx.closePath();
            ctx.stroke();
            ctx.globalAlpha = 0.1;
            ctx.lineWidth = 1;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(b[0].x, b[0].y);
            ctx.lineTo(b[1].x, b[1].y);
            ctx.lineTo(b[2].x, b[2].y);
            ctx.lineTo(b[3].x, b[3].y);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b[4].x, b[4].y);
            ctx.lineTo(b[5].x, b[5].y);
            ctx.lineTo(b[6].x, b[6].y);
            ctx.lineTo(b[7].x, b[7].y);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b[0].x, b[0].y);
            ctx.lineTo(b[1].x, b[1].y);
            ctx.lineTo(b[5].x, b[5].y);
            ctx.lineTo(b[4].x, b[4].y);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b[1].x, b[1].y);
            ctx.lineTo(b[2].x, b[2].y);
            ctx.lineTo(b[6].x, b[6].y);
            ctx.lineTo(b[5].x, b[5].y);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b[2].x, b[2].y);
            ctx.lineTo(b[3].x, b[3].y);
            ctx.lineTo(b[7].x, b[7].y);
            ctx.lineTo(b[6].x, b[6].y);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b[3].x, b[3].y);
            ctx.lineTo(b[0].x, b[0].y);
            ctx.lineTo(b[4].x, b[4].y);
            ctx.lineTo(b[7].x, b[7].y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        };
        
        function Random(min, max, isFloat) {
            if (!min) {
                return Math.random();
            } else if (!max) {
                return Math.round(Math.random() * min);
            } else {
                if (!isFloat) {
                    return Math.round((Math.random() * (max - min)) + min);
                } else {
                    return Math.random() * (max - min) + min;
                }
            }
        }
        
        function Hex2color(hex){
            var r = (hex >> 16 & 0xff).toString(16),
                g = (hex >>  8 & 0xff).toString(16),
                b = (hex       & 0xff).toString(16);
                
            r = r.length === 2 ? r : "0" + r;
            g = g.length === 2 ? g : "0" + g;
            b = b.length === 2 ? b : "0" + b;
            
            return "#" + r + g + b;
        }
        
        function RGB(color){
            var c;
            
            c = parseInt(color.slice(1), 16);
            
            var r = c >> 16 & 0xff,
                g = c >>  8 & 0xff,
                b = c       & 0xff;
                
            return "rgb(" + r + ", " + g + ", " + b + ")";
        }
        
        main();
    })(window);
</script>
<!-- END BACKGROUND -->